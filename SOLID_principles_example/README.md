# SOLID Principles with Python Examples

This repository provides examples of SOLID principles implemented in Python. Each principle is explained briefly and accompanied by code samples.

## Table of Contents

- [SOLID Principles](#solid-principles)
  - [Single Responsibility Principle (SRP)](#single-responsibility-principle-srp)
  - [Open/Closed Principle (OCP)](#openclosed-principle-ocp)
  - [Liskov Substitution Principle (LSP)](#liskov-substitution-principle-lsp)
  - [Interface Segregation Principle (ISP)](#interface-segregation-principle-isp)
  - [Dependency Inversion Principle (DIP)](#dependency-inversion-principle-dip)
- [Usage](#usage)
- [Contributing](#contributing)
- [License](#license)

## SOLID Principles

SOLID is an acronym that represents five design principles that help create maintainable and scalable software architectures.

### Single Responsibility Principle (SRP)

The SRP states that a class should have only one reason to change. In other words, a class should have only one responsibility.

### Open/Closed Principle (OCP)


The OCP states that software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.

### Liskov Substitution Principle (LSP)
The LSP states that objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program.

### Interface Segregation Principle (ISP)

The ISP states that clients should not be forced to depend on interfaces they do not use. In other words, keep interfaces small and specific.

### Dependency Inversion Principle (DIP)

The DIP states that high-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.




